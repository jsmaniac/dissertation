\begin{schemeregion}
\section{Inference and Integration}
\label{sec:infer}

Translating the calculus into a viable extension of Typed Scheme
requires two engineering steps.  First, the addition of starred and
dotted type variables interacts with the local type inference system
of Typed Scheme.  Second, Typed Scheme supports several language
constructs that benefit from the type calculus, in particular
case-based \scheme|lambda| expressions and the multiple value return
mechanism.  


\subsection{Local Type Inference}

To maintain the convenience of Typed Scheme for programmers,
we must integrate variable-arity polymorphism into the
framework of local type inference~\cite{pierce:lti},
 while preserving the desirable
properties of both.  This means that it must be possible to use
variable-arity functions such as \scheme{map} without necessarily
explicitly instantiating them at appropriate types (for most cases).  Further, the
inference algorithm must handle all of the features described in
section~\ref{sec:formal}.  

Unfortunately, lack of space prevents us from presenting a formal
description of our extension to Pierce and Turner's system.
Instead,  we sketch the two most important changes required to handle
variable-arity polymorphism.
 First, the constraint generation mechanism must create
constraints for type relationships involving dotted pre-types.
Second, the resulting substitution must handle the presence of
dotted pre-types in the result type of functions.

\paragraph{Constraint Generation}

The heart of the Pierce and Turner algorithm  generates
subtyping constraints on the type variables in the type of a
polymorphic function.  
 All constraints are of the form of an
upper and lower bound for each type variable.\footnote{We use $=$ when the bounds are the same, and omit trivial bounds.}
For example, if we have the 
application \scheme|(map add1 (list 1 2 3))|, where \scheme|map| has the type \scheme|(All (alpha beta) ((alpha ->
beta) (Listof alpha) -> (Listof beta)))|,
then we would generate the constraints  
\[\alpha =
\hbox{\scheme|Integer|}, \hbox{\scheme|Integer|} <: \beta\]
 From
these constraints, we can generate a substitution that maps both
$\alpha$ and $\beta$ to \scheme|Integer|, giving a result type of
\scheme| (Listof Integer) |. 


\newcommand{\integer}{\hbox{\scheme|Integer|}}
\newcommand{\boolean}{\hbox{\scheme|Boolean|}}

When variable-arity polymorphism is introduced, such simple
constraints no longer suffice.  For example, in this world,  the type for
\scheme|map| is
\begin{schemedisplay}
(All (gamma alpha beta ...)
  ((alpha beta dotsb -> gamma) (Listof alpha) (Listof beta) dotsb -> (Listof gamma))))
\end{schemedisplay}
meaning that the application 
\begin{schemedisplay}
(map modulo (list 10 20 30) (list 5 2 3))  
\end{schemedisplay}
 requires that \scheme|beta| be expanded into a single instance of
\scheme|Integer|.  

To this end, we extend our
language of constraints.  Instead of merely providing bounds for each
type variable, a dotted type variable can be constrained to map to a
sequence of new type variables, each with its own constraints.  In
the above example, we would say that $\beta$ is mapped to a singleton
list of type variables $[\beta_1]$, which has the constraint $\beta_1 =
\hbox{\scheme|Integer|}$. This is in addition to the standard
constraints generated by this application, which include $\alpha =
\hbox{\scheme|Integer|}$ and $\integer <: \gamma$.

Once such constraint sets are generated, they need to be combined and normalized.
For example, the constraints for the first argument in the above
expression are $\alpha <: \integer$, $\integer <: \gamma$ and $\beta_1
<: \integer$, where $\beta_1$ is generated from $\beta$. The only
constraint from the second argument is $\integer <: \alpha$.  Finally,
the constraint from the third argument is $\integer <: \beta_1$.
Combining the constraints for $\alpha$ and $\gamma$ is
straightforward, and follows the original algorithm.  For the sequence
of type variables generated for $\beta$ (here just $\beta_1$), we
combine them pairwise, giving the constraints for the entire
application above.

In addition, we need to handle combinations of
uniform and non-uniform variable-arity functions.  Recall that the
type of \scheme|+| is \scheme|(Integer$^*$ -> Integer)|.  Then
inference for the application
\begin{schemedisplay}
(map + (list 1 2 3) (list 10 20 30) (list 100 200 300))
\end{schemedisplay}
generates the constraint
 \[\hbox{\scheme|(Integer$^*$ -> Integer)|} <: \hbox{\scheme|(alpha beta dotsb -> gamma)|}\]
  This yields the same
constraints for $\alpha$ and $\gamma$ as above, but for $\beta$, the
constraint set must record that the number of types for $\beta$ is not
yet fixed and that all types substituted for $\beta$ are bounded
above by $\integer$.  We record this as a constraint directly on
$\beta$.  When the constraints for the three list
arguments are generated, we generate precisely two new type
variables for $\beta$.  Since the bounds match appropriately, this
results in the final constraints of $\beta_1 = \integer$ and
$\beta_2 = \integer$, and no constraints on $\beta$ since the number
of arguments has been fixed.  



\paragraph{Generating Substitutions}

Once the full set of constraints is generated for an
application, we solve them, i.e., we derive a substitution from the constraint
set. The substitution is then applied to the result type of the operand.  In
the above examples with \scheme|map|, the substitution is simply
$\gamma \mapsto \hbox{\scheme| (Listof Integer) |}$.  For other
 function types, however, the substitution may be more
complex.  For example, given a function 
\begin{schemedisplay}
(: f (All (alpha ...) ((alpha dotsa -> Integer) -> (alpha dotsa -> Integer)))
\end{schemedisplay}
 the application \scheme|(f modulo)| generates
 $\alpha_1 <: \integer$ and $\alpha_2 <: \integer$, which satisfy
\[\hbox{\scheme|(alpha dotsa -> Integer)|} <: \hbox{\scheme| (Integer Integer
  -> Integer) |}.\]
The resulting substitution should replace the dotted pre-type
\scheme|alpha dotsa| with the sequence \scheme|Integer Integer|.  To represent such a
substitution, we extend our notion of a substitution to allow a single
type variable to map to \emph{multiple} types.  Here, the resulting
substitution  is $\alpha \mapsto [\integer, \integer]$.

Again, the presence of uniform rest arguments complicates the
picture.  Consider \scheme|(f -)|, where $\hbox{\scheme|-|} : 
\hbox{\scheme|(Integer Integer$^*$ -> Integer)|}$.
The constraint set contains
$\integer <: \alpha_1$ and $\integer <: \alpha$, with no upper bound on the number of arguments.
Therefore, the  substitution should produce the result type
\scheme|(Integer Integer$^*$ -> Integer)|.  We represent such a
substitution as \[\alpha \mapsto [\integer, \integer^*]\]

Given these extensions to the original local type inference algorithm,
we are able to infer the types for all applications of variable-arity
polymorphic functions, provided that the types of the actual argument expressions are
sufficient to determine the result type.  

\subsection{Integrating with Typed Scheme}

The calculus presented in section \ref{sec:formal} is obviously not
the whole of Typed Scheme.  Several constructs of the full language,
 such as multiple values and \scheme|case-lambda|, interact in interesting ways with
variable-arity polymorphism.


\paragraph{Functions with {\keywordfont{case-lambda}}}

In addition to variable-arity functions, PLT Scheme also supports the
\scheme|case-lambda| construct, which creates functions that have
different bodies for different arities.  For example, given this definition

\begin{schemedisplay}
(define f (case-lambda [(x)   1]
                       [(x y) 2]))
\end{schemedisplay}

\noindent
\scheme|(f 'a)| yields \schemeresult|1| and \scheme|(f 'a 'b)| gives
\schemeresult|2|.  The semantics of \scheme|case-lambda| tries the
clauses in order, and the first clause to accept the given number of
arguments is used.  Through the \scheme|case-lambda| type, which was
introduced in section~\ref{ssec:approx-va}, Typed Scheme supports 
functions defined in this paper.

In order to support such types in the local inference algorithm, we
must consider each conjunct of the type in turn.  For example, if we
are interested in an instantiation of \scheme|(alpha dotsa -> beta)|
that makes it a supertype of 
\begin{schemedisplay}
(case-lambda (Integer -> Integer)
             (Integer Boolean -> Integer))
\end{schemedisplay}
 there are multiple possibilities.  The
two possible constraint sets, via the algorithm described above,
 are \[\{ \alpha_1 <: \integer, \integer <: \beta\}\]
and \[\{ \alpha_1 <: \integer, \alpha_2 <: \boolean, \integer <: \beta\}\]  

Therefore, a call to the constraint generator must return multiple
possibilities.  When two such lists of constraint sets are
combined, we take the cartesian product of the combinations, excluding
those that cannot be combined because they have incompatible
constraints.  Although such cross-combinations could generate extremely large sets,
in practice it has not been noticeable.  After generating the final
list of constraint sets, if a substitution is needed, it can be generated
from any constraint set.

The other change needed to accommodate \scheme|case-lambda| is that
type-checking a function application must check each conjunct in
turn.  While this complicates the implementation of the type-checker,
it introduces no problems for the novel aspects of variable-arity
polymorphism.  

\paragraph{Multiple Values}

Scheme, and therefore Typed Scheme, allows expressions to return
multiple values simultaneously.  These multiple values are not packaged in a data
structure, and only certain contexts accept
multiple values.  Just as argument sequences are a natural
place to allow variable-length sequences, however, multiple values fit
naturally with variable arity as well.  

The basic extension to Typed Scheme in support of variable-arity multiple
values is to allow dotted pre-types such as \scheme|(Values Boolean alpha
dotsa)|.  While this, as with other dotted pre-types, cannot be the type
of a closed expression, it can appear as the result type of a
polymorphic function.  

The combination of multiple values and variable-arity polymorphism
allows us to give types to Scheme primitives such as \scheme|values|
and \scheme|call-with-values|.  The \scheme|values| function takes any
number of arguments, and returns all of them as multiple values.  Its
type is
\begin{schemedisplay}
(All (alpha ...) (alpha dotsa -> (Values alpha dotsa)))
\end{schemedisplay}
  The \scheme|call-with-values| function is one of the fundamental
mechanisms for consuming multiple values.  It takes a producer thunk,
which produces some number of values, and a consumer function, which
accepts that number of arguments, and wires them together.  Thus, its type
is 
\begin{schemedisplay}
(All (beta alpha ...) ((-> (Values alpha dotsa)) (alpha dotsa -> beta) -> beta))
\end{schemedisplay}
Previous work on type systems for Scheme has not been able to
statically check such uses of multiple values.  

\paragraph{Operations on Rest Parameters}


The standard \scheme|map|, \scheme|ormap|, and
\scheme|andmap| functions are treated specially in Typed Scheme when
applied to rest parameters and expressions classified by dotted
pre-types.  These uses correspond to the \scheme|lift|, \scheme|any|,
and \scheme|all| special forms used in the calculus of section
\ref{sec:formal}.

Finally, since rest parameters, even those classified by dotted pre-types, are
represented by lists at runtime in Typed Scheme, we allow these rest
parameters to be used in contexts that expect lists, dropping the
additional information in the dotted pre-type.  This supports many common Scheme
idioms, such as printing the list of arguments in a debugging mode.  



\end{schemeregion}
